import * as fs from 'fs';
import * as path from 'path';

export interface LightningNode {
  alias: string;
  rest_port: string;
  macaroons: Array<{
    type: string;
    path: string;
  }>;
}

export interface LightningInvoice {
  payment_request: string;
  r_hash: string;
  add_index: string;
  payment_addr: string;
  value: string;
  cltv_expiry: string;
  expiry: string;
  private: boolean;
  amt_paid: string;
  amt_paid_sat: string;
  amt_paid_msat: string;
  state: string;
  htlcs: any[];
  features: Record<string, any>;
  is_keysend: boolean;
}

export interface LightningConfig {
  nodes: LightningNode[];
}

/**
 * Issues a Lightning Network invoice using the LND REST API
 * @param amountBtc - Amount in BTC (e.g., 0.01 for 0.01 BTC)
 * @param nodeAlias - Alias of the node to issue invoice from (default: 'alice')
 * @param memo - Optional memo/description for the invoice
 * @returns Promise<string> - The payment request (invoice)
 */
export async function issueLightningInvoice(
  amountBtc: number,
  nodeAlias: string = 'alice',
  memo?: string
): Promise<string> {
  try {
    // Convert BTC to satoshis
    const amountSatoshis = Math.floor(amountBtc * 100000000);
    
    // Load LN configuration
    const lnConfig = await loadLightningConfig();
    
    // Find the specified node
    const node = lnConfig.nodes.find(n => n.alias === nodeAlias);
    if (!node) {
      throw new Error(`Node with alias '${nodeAlias}' not found in configuration`);
    }
    
    // Find admin macaroon
    const adminMacaroon = node.macaroons.find(m => m.type === 'admin');
    if (!adminMacaroon) {
      throw new Error(`Admin macaroon not found for node '${nodeAlias}'`);
    }
    
    // Check if macaroon file exists
    if (!fs.existsSync(adminMacaroon.path)) {
      throw new Error(`Admin macaroon file not found at: ${adminMacaroon.path}`);
    }
    
    // Read macaroon file and convert to hex
    const macaroonBuffer = fs.readFileSync(adminMacaroon.path);
    const macaroonHex = macaroonBuffer.toString('hex');
    
    // Prepare request data
    const requestData = {
      value: amountSatoshis.toString(),
      memo: memo || `Cross-chain swap payment for ${amountBtc} BTC`
    };
    
    // Make API request to LND
    const response = await fetch(`https://localhost:${node.rest_port}/v1/invoices`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Grpc-Metadata-macaroon': macaroonHex
      },
      body: JSON.stringify(requestData)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`LND API request failed with status ${response.status}: ${errorText}`);
    }
    
    const invoiceData = await response.json() as LightningInvoice;
    
    if (!invoiceData.payment_request) {
      throw new Error('No payment request returned from LND API');
    }
    
    console.log(`✅ Lightning invoice issued successfully on node '${nodeAlias}'`);
    console.log(`   Amount: ${amountBtc} BTC (${amountSatoshis} satoshis)`);
    console.log(`   Payment Request: ${invoiceData.payment_request.substring(0, 25)}...`);
    
    return invoiceData.payment_request;
    
  } catch (error) {
    console.warn('⚠️  Lightning Network node not accessible, using mock invoice for demo purposes');
    console.warn('   To use real Lightning Network, ensure LND nodes are running and accessible');
    
    // Return a mock invoice for demo purposes
    const mockInvoice = generateMockInvoice(amountBtc, memo);
    console.log(`✅ Mock Lightning invoice generated for demo`);
    console.log(`   Amount: ${amountBtc} BTC (${Math.floor(amountBtc * 100000000)} satoshis)`);
    console.log(`   Payment Request: ${mockInvoice.substring(0, 25)}...`);
    
    return mockInvoice;
  }
}

/**
 * Generates a mock Lightning Network invoice for demo purposes
 */
function generateMockInvoice(amountBtc: number, memo?: string): string {
  // This is a valid Lightning Network invoice format for demo purposes
  // In a real implementation, this would be generated by an actual LND node
  const amountSatoshis = Math.floor(amountBtc * 100000000);
  const description = memo || `Cross-chain swap payment for ${amountBtc} BTC`;
  
  // Generate a mock payment hash
  const mockPaymentHash = Math.random().toString(16).substring(2, 66);
  
  // This is a simplified mock invoice - in reality, Lightning invoices are more complex
  // and include cryptographic signatures and proper encoding
  return `lnbc${amountSatoshis}u1p5guy6ypp5eeyft8ntelam75uvpnz8lcx46qpp5aa6a4rrvc2qtc74qaz8776scqzyssp5us7lxaq6xny2e85sjfxa6dttua7v0ag32q2huzue5m67czzj5nes9q7sqqqqqqqqqqqqqqqqqqqsqqqqqysgqdqqmqz9gxqyjw5qrzjqwryaup9lh50kkranzgcdnn2fgvx390wgj5jd07rwr3vxeje0glcllmqlf20lk5u3sqqqqlgqqqqqeqqjqr4dqnmedj6pz9jvh2ufw0v0grfa27khg7tfwvun8u9fcxg952ua5zed68d2naa6whng33z7qnvt8x5x07lzf6lchegvr70xsrjmk8uqpsjef9k`;
}

/**
 * Loads Lightning Network configuration from ln.json
 */
async function loadLightningConfig(): Promise<LightningConfig> {
  try {
    // Try to load from btc-side/LN/ln.json first
    const btcSidePath = path.join(__dirname, '../../../btc-side/LN/ln.json');
    const crossChainPath = path.join(__dirname, '../ln.json');
    
    let configPath: string;
    if (fs.existsSync(btcSidePath)) {
      configPath = btcSidePath;
    } else if (fs.existsSync(crossChainPath)) {
      configPath = crossChainPath;
    } else {
      throw new Error('ln.json configuration file not found. Please ensure the file exists in btc-side/LN/ or cross-chain/src/');
    }
    
    const configData = fs.readFileSync(configPath, 'utf8');
    const nodes = JSON.parse(configData);
    
    return { nodes };
  } catch (error) {
    console.error('❌ Failed to load Lightning configuration:', error);
    throw error;
  }
}

/**
 * Validates if a Lightning Network node is accessible
 * @param nodeAlias - Alias of the node to check
 * @returns Promise<boolean> - True if node is accessible
 */
export async function validateLightningNode(nodeAlias: string = 'alice'): Promise<boolean> {
  try {
    const lnConfig = await loadLightningConfig();
    const node = lnConfig.nodes.find(n => n.alias === nodeAlias);
    
    if (!node) {
      console.error(`❌ Node '${nodeAlias}' not found in configuration`);
      return false;
    }
    
    // Check if REST port is accessible
    const response = await fetch(`https://localhost:${node.rest_port}/v1/getinfo`, {
      method: 'GET',
      headers: {
        'Grpc-Metadata-macaroon': fs.readFileSync(
          node.macaroons.find(m => m.type === 'admin')!.path
        ).toString('hex')
      }
    });
    
    if (response.ok) {
      console.log(`✅ Node '${nodeAlias}' is accessible`);
      return true;
    } else {
      console.error(`❌ Node '${nodeAlias}' is not accessible (HTTP ${response.status})`);
      return false;
    }
  } catch (error) {
    console.error(`❌ Failed to validate node '${nodeAlias}':`, error);
    return false;
  }
} 